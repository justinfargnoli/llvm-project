; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc < %s -march=nvptx64 | FileCheck %s
; RUN: %if ptxas %{ llc < %s -march=nvptx64 | %ptxas-verify %}

target datalayout = "e-p:64:64:64-p3:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-i128:128:128-f32:32:32-f64:64:64-f128:128:128-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64-a:8:8"
target triple = "nvptx64-nvidia-cuda"

define void @t1() {
; CHECK-LABEL: t1(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<2>;
; CHECK-NEXT:    .reg .b64 %rd<2>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.b64 %rd1, 0;
; CHECK-NEXT:    ld.global.b16 %r1, [%rd1];
; CHECK-NEXT:    st.global.v4.b32 [%rd1], {%r1, 0, 0, 0};
; CHECK-NEXT:    ret;
entry:
  %0 = load <2 x i8>, ptr addrspace(1) null, align 4
  %1 = shufflevector <2 x i8> %0, <2 x i8> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = bitcast <4 x i8> %1 to i32
  %3 = insertelement <4 x i32> zeroinitializer, i32 %2, i64 0
  store <4 x i32> %3, ptr addrspace(1) null, align 16
  ret void
}

define void @t2() {
; CHECK-LABEL: t2(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<2>;
; CHECK-NEXT:    .reg .b64 %rd<2>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    mov.b64 %rd1, 0;
; CHECK-NEXT:    ld.global.b16 %r1, [%rd1];
; CHECK-NEXT:    st.local.b32 [%rd1], %r1;
; CHECK-NEXT:    ret;
entry:
  %0 = load <2 x i8>, ptr addrspace(1) null, align 8
  %1 = shufflevector <2 x i8> %0, <2 x i8> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  store <4 x i8> %1, ptr addrspace(5) null, align 8
  ret void
}

declare <2 x i8> @llvm.nvvm.ldg.global.i.v2i8.p1(ptr addrspace(1) %ptr, i32 %align)

define void @ldg(ptr addrspace(1) %ptr) {
; CHECK-LABEL: ldg(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<2>;
; CHECK-NEXT:    .reg .b64 %rd<3>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ld.param.b64 %rd1, [ldg_param_0];
; CHECK-NEXT:    ld.global.b16 %r1, [%rd1];
; CHECK-NEXT:    mov.b64 %rd2, 0;
; CHECK-NEXT:    st.local.b32 [%rd2], %r1;
; CHECK-NEXT:    ret;
entry:
  %0 = tail call <2 x i8> @llvm.nvvm.ldg.global.i.v2i8.p1(ptr addrspace(1) %ptr, i32 2)
  %1 = shufflevector <2 x i8> %0, <2 x i8> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  store <4 x i8> %1, ptr addrspace(5) null, align 8
  ret void
}

declare <2 x i8> @llvm.nvvm.ldu.global.f.v2i8.p1(ptr addrspace(1) %ptr, i32 %align)

define void @ldu(ptr addrspace(1) %ptr) {
; CHECK-LABEL: ldu(
; CHECK:       {
; CHECK-NEXT:    .reg .b16 %rs<2>;
; CHECK-NEXT:    .reg .b32 %r<2>;
; CHECK-NEXT:    .reg .b64 %rd<3>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    ld.param.b64 %rd1, [ldu_param_0];
; CHECK-NEXT:    ldu.global.b16 %rs1, [%rd1];
; CHECK-NEXT:    cvt.u32.u16 %r1, %rs1;
; CHECK-NEXT:    mov.b64 %rd2, 0;
; CHECK-NEXT:    st.local.b32 [%rd2], %r1;
; CHECK-NEXT:    ret;
entry:
  %0 = tail call <2 x i8> @llvm.nvvm.ldu.global.i.v2i8.p1(ptr addrspace(1) %ptr, i32 2)
  %1 = shufflevector <2 x i8> %0, <2 x i8> zeroinitializer, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  store <4 x i8> %1, ptr addrspace(5) null, align 8
  ret void
}

define void @t3() {
; CHECK-LABEL: t3(
; CHECK:       {
; CHECK-NEXT:    .reg .b32 %r<2>;
; CHECK-NEXT:    .reg .b64 %rd<2>;
; CHECK-EMPTY:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov.b64 %rd1, 0;
; CHECK-NEXT:    ld.global.b16 %r1, [%rd1];
; CHECK-NEXT:    st.global.v2.b32 [%rd1], {%r1, 0};
; CHECK-NEXT:    ret;
  %1 = load <2 x i8>, ptr addrspace(1) null, align 2
  %insval2 = bitcast <2 x i8> %1 to i16
  %2 = insertelement <4 x i16> zeroinitializer, i16 %insval2, i32 0
  store <4 x i16> %2, ptr addrspace(1) null, align 8
  ret void
}
